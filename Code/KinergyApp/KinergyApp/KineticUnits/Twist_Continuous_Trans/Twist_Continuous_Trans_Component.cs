using System;
using System.Collections.Generic;
using Kinergy.Geom;
using Kinergy.KineticUnit;
using Kinergy.Utilities;
using Grasshopper.Kernel;
using Rhino.Geometry;

namespace HumanUIforKinergy.KineticUnits.Twist_Continuous_Trans
{
    public class Twist_Continuous_Trans_Component : GH_Component
    {
        Twist_Continuous_Trans KU ;
        Brep model;
        Brep innerCylinder;
        Vector3d mainDirection;
        bool SIH;
        bool SE;
        bool addLock;
        double strength = 0, displacement = 0;
        int camType = 0;
        /// <summary>
        /// Initializes a new instance of the Twist_Continuous_Trans_Component class.
        /// </summary>
        public Twist_Continuous_Trans_Component()
          : base("Twist_Continuous_Trans_Component", "TTC",
              "Description",
              "Kinergy", "KineticUnits")
        {
            model = null;
            innerCylinder = null;
            mainDirection = Vector3d.Unset;
            SIH = false;
            SE = false;
            addLock = false;
            KU = null;
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddBrepParameter("Input Model", "M", "The base inout model", GH_ParamAccess.item);
            pManager.AddBrepParameter("Inner Cylinder", "C", "The cylinder generated by preprocessing cell", GH_ParamAccess.item);
            pManager.AddVectorParameter("Main Direction", "D", "The main direction of kinetic unit, generated by preprocessing cell", GH_ParamAccess.item);
            pManager.AddBooleanParameter("Set Input handler", "SIH", "Whether to set input handler. Please beware that this boolean input could be repeatedly triggered, each time reset previous input", GH_ParamAccess.item);
            pManager.AddBooleanParameter("Set End-Effector", "SE", "Whether to set end-effector model.Please beware that this boolean input could be repeatedly triggered, each time reset previous input", GH_ParamAccess.item);
            pManager.AddNumberParameter("Strength", "S", "Strength parameter, which influence the strength of inner knietic component.", GH_ParamAccess.item);
            pManager.AddNumberParameter("Displacement", "D", "Displacement parameter, which influence the maximum extent of moving.", GH_ParamAccess.item);
            pManager.AddIntegerParameter("Cam Type", "CT", "The type of cam required. 1 for ellpise and 2 for snail", GH_ParamAccess.item);
            pManager.AddBooleanParameter("AddLock", "L", "Whether to add lock", GH_ParamAccess.item);
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddGenericParameter("KinticUnit", "KU","", GH_ParamAccess.item);
            pManager.AddBrepParameter("Generated models as Breps", "M", "", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            Brep model_input = null;
            Brep innerCylinder_input = null;
            Vector3d direction_input = Vector3d.Unset;
            bool SIH_input = false, SE_input = false,addLock_input=false;
            int camType_input = 0;
            double strength_input = 0, displacement_input = 0;
            #region input params
            if (!DA.GetData(0, ref model_input))
                return;
            if (!DA.GetData(1, ref innerCylinder_input))
                return;
            if (!DA.GetData(2, ref direction_input))
                return;
            if (!DA.GetData(3, ref SIH_input))
                return;
            if (!DA.GetData(4, ref SE_input))
                return;
            if (!DA.GetData(5, ref strength_input))
                return;
            if (!DA.GetData(6, ref displacement_input))
                return;
            if (!DA.GetData(7, ref camType_input))
                return;
            if (!DA.GetData(8, ref addLock_input))
                return;
            if (camType_input != 1 && camType_input != 2)
                throw new Exception("Invalid cam type provided! Now we only support 1 and 2");
            #endregion
            bool toGenerate = false, toAdjustParam = false, toSetInputHandler = false, toSetEndEffector = false, toAddLock = false, toRemoveLock = false,toRegenCam=false ;
            #region input check. This determines how the cell respond to changed params
            if (model != model_input)//This applies to starting situation and when u change the input model
            {
                model = model_input;
                toGenerate = true;
            }
            if(mainDirection==Vector3d.Unset)
            {
                mainDirection = direction_input;
                toGenerate = true;
            }
            else if (mainDirection.IsParallelTo( direction_input)!=1)//This applies to starting situation and when u change the input direction
            {
                mainDirection = direction_input;
                toGenerate = true;
            }
            if(!toGenerate && !GeometryMethods.IfCylinderBrepIsEqual(innerCylinder,innerCylinder_input,mainDirection))
            {
                innerCylinder = innerCylinder_input;
                toGenerate = true;
            }
            if(SIH_input&&SIH!=SIH_input)//SIH_input is true and SIH == false. Notice that if SIH stays true, do not respond to it
            {
                toSetInputHandler = true;
            }
            if(SE_input&&SE!=SE_input)
            {
                toSetEndEffector = true;
            }    
            if(addLock!=addLock_input)
            {
                addLock = addLock_input;
                if (addLock)
                    toAddLock = true;
                else
                    toRemoveLock = true;
            }
            if(strength_input==strength && displacement==displacement_input)//Params stays same, nothing happens
            {
                toAdjustParam = false;
            }
            else
            {
                strength = strength_input;
                displacement = displacement_input;
                toAdjustParam = true;
            }
            if(camType!=camType_input)
            {
                camType = camType_input;
                if (!toGenerate)
                    toRegenCam = true;
            }
            #endregion
            if (toGenerate)
                KU = new Twist_Continuous_Trans(model, innerCylinder, mainDirection, strength, displacement,toAddLock,camType);
            if (!toGenerate && toAdjustParam)
                KU.AdjustParam(strength, displacement);
            if (toAddLock)
                KU.ConstructLocks();
            if (toRemoveLock)
                KU.RemoveLocks();
            if (toSetInputHandler)
                KU.SetInputHandler();
            if (toSetEndEffector)
                KU.SetEndEffector();
            if (toRegenCam)
                KU.GenerateCamAndFollower(camType);
            DA.SetData(0, KU);
            DA.SetDataList(1, KU.GetModel(new List<string> { "Spiral", "Axis" }));
        }

        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return null;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("a4daf6d2-b76b-4592-9709-a1e299bdc0c8"); }
        }
    }
}